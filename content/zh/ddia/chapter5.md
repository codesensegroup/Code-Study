---
title: 'Chapter 05 複製'
description: 'Chapter 05 複製'
position: 295
category: 資料密集型應用系統設計
menuTitle: 'Chapter 05'
contributors: ['pomeloJ']
---

<style>
  tr, th, td {
    border: none!important;
  }
  .nolinebreak {
    white-space: nowrap;
  }
  .movepadding {
    padding-left: 2%!important;
  }
</style>

## 引言
- 複製資料的目的：
    - 使資料與使用者在地理上接近（減少延遲）
    - 提高系統可用性（即使部分故障）
    - 提高讀取吞吐量（伸縮讀請求機器數量）

- 複製資料系統的挑戰：
    - 假設資料集非常小
    - 假設每臺機器可以儲存整個資料集的副本
    - 處理資料的變更

- 變更複製演算法：
    - 單領導者（single leader）
    - 多領導者（multi leader）
    - 無領導者（leaderless）

- 複製權衡：
    - 同步複製 vs 非同步複製
    - 處理失敗的副本

- 複製算法歷史：
    - 70 年代研究
    - 分散式資料庫變為主流

- 複製延遲問題：
    - 最終一致性（eventual consistency）
    - 讀己之寫（read-your-writes）
    - 單調讀（monotonic read）

## 領導者與追隨者
- 副本（replica）：儲存資料庫複製的節點。

    - 確保所有資料落在所有副本上的問題：
        向資料庫的寫入操作需要傳播到所有副本。

    - 基於領導者的複製（leader-based replication）：
        - 領導者（leader）：負責接收寫入操作。
        - 追隨者（followers）：負責拉取日誌並更新本地資料庫副本。

    - 複製過程：
        - 客戶端將寫入請求傳送給領導者。
        - 領導者將新資料寫入本地儲存。
        - 領導者將資料變更傳送給所有追隨者（複製日誌/變更流）。
        - 追隨者按照相同處理順序更新本地資料庫副本。

    - 讀取操作：客戶端可以向領導者或任一追隨者進行查詢。

    - 基於領導者的複製應用範例：
        - 關係資料庫：PostgreSQL（9.0 版本開始）、MySQL、Oracle Data Guard、SQL Server 的 AlwaysOn 可用性組。
        - 非關係資料庫：MongoDB、RethinkDB、Espresso。
        - 分散式訊息代理：Kafka、RabbitMQ 高可用佇列。
        - 網路檔案系統：DRBD 等塊複製裝置。

<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-1.png" />
</div>

- 圖 5-1 基於領導者的（主/從）複製

## 同步複製與非同步複製
- 複製細節：複製可以是同步（synchronously）或非同步（asynchronously）。
    - 同步複製：主庫在報告寫入成功前，需要等待從庫確認已收到寫入操作。
    - 非同步複製：主庫傳送訊息，但不等待從庫響應。

- 同步複製的優缺點：
    - 優點：從庫保證有與主庫一致的最新資料副本。
    - 缺點：同步從庫無響應時，主庫無法處理寫入操作。

- 半同步複製（semi-synchronous）：
    - 一個從庫是同步的，其他的從庫則是非同步的。
    - 同步從庫不可用或緩慢時，將一個非同步從庫改為同步執行。

- 完全非同步複製：
    - 主庫失效且不可恢復時，尚未複製給從庫的寫入會丟失。
    - 優點：主庫可以繼續處理寫入，即使所有從庫都落後。

- 鏈式複製（chain replication）：
    - 同步複製的一種變體，旨在不丟資料並提供良好效能和可用性。
    - 已在一些系統中實現，例如 Microsoft Azure Storage。
<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-2.png" />
</div>

- 圖 5-2 基於領導者的複製：一個同步從庫和一個非同步從庫

- 複製的一致性與共識（consensus）：
    - 第九章將詳細探討共識理論。
    - 本章主要討論實踐中的資料庫常用的簡單複製形式。

- 設定新從庫：
    - 獲取主庫一致性快照。
    - 將快照複製到新的從庫節點。
    - 從庫連線到主庫並拉取快照後的所有資料變更。
    - 從庫趕上主庫後，可以繼續及時處理主庫資料變化。

- 處理節點宕機：
    - 以基於領導者的複製實現高可用。

- 從庫失效：追趕恢復
    - 重新連線到主庫。
    - 請求並處理斷開期間的所有資料變更。

- 主庫失效：故障切換
    - 確認主庫失效。
    - 選擇新的主庫。
    - 重新配置系統以啟用新的主庫。

- 故障切換過程中可能出現的問題：
    - 非同步複製導致資料損失。
    - 與其他外部儲存協調時的問題。
    - 腦裂問題。
    - 超時配置的困難。

儘管有些軟體支援自動故障切換，但許多運維團隊仍更願意手動執行故障切換。

- 分散式系統中的基本問題包括節點故障、不可靠的網路、副本一致性、永續性、可用性和延遲。這些問題將在第八章和第九章中深入討論。

- 複製日誌的實現可以分為以下幾種：

    - 基於語句的複製：主庫記錄每個寫入請求並將語句日誌傳送給從庫。但這種方式存在諸多問題，如非確定性函式、自增列、副作用等。
    - 傳輸預寫式日誌（WAL）：主庫將日誌通過網路傳送給從庫。此方法使複製與儲存引擎緊密耦合，升級資料庫軟體可能需要停機。
    - 邏輯日誌複製（基於行）：對複製和儲存引擎使用不同的日誌格式，使主庫和從庫能夠執行不同版本的資料庫軟體或儲存引擎。邏輯日誌格式更容易解析，有利於資料變更捕獲（change data capture）。
    - 基於觸發器的複製：通過資料庫中的觸發器和儲存過程，將資料更改記錄到單獨的表中，再使用外部程式讀取該表並將資料變更複製到另一個系統。儘管開銷較大且容易出錯，但基於觸發器的複製具有很高的靈活性。

以上四種複製方式各有優缺點，具體應用需根據實際情況選擇合適的複製方法。

## 複製延遲問題
- 複製的原因
    - 容忍節點故障
    - 可伸縮性（處理比單個機器更多的請求）
    - 延遲（讓副本在地理位置上更接近使用者）

- 基於領導者的複製與最終一致性
    - 只讀查詢可以由任何一個副本來處理
    - 讀伸縮體系結構
        - 新增更多的從庫，提高只讀請求的服務容量
        - 實際上只適用於非同步複製
    - 最終一致性
        - 非同步從庫讀取可能看到過時的資訊
        - 副本落後的程度是沒有限制的
        - 複製延遲可能僅僅是幾分之一秒或達到幾分鐘
- 複製延遲問題與解決方法
    - 問題例項
        - 不一致性是應用設計中的真實問題
        - 三個可能發生的問題例項

- 讀己之寫

    - 適用情境
        - 應用讓使用者提交資料並檢視提交內容
        - 資料經常被檢視，偶爾寫入
    - 非同步複製的問題
        - 寫入後馬上檢視資料，新資料可能尚未到達副本
        - 使用者可能看到資料丟失

<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-3.png" />
</div>

- 圖 5-3 使用者寫入後從舊副本中讀取資料。需要寫後讀 (read-after-write) 的一致性來防止這種異常

- 寫後讀一致性
    - 定義
        - 使用者重新載入頁面時，總是看到自己提交的更新
        - 不對其他使用者的寫入做出承諾
    - 實現方法
        - 對使用者可能修改過的內容，總是從主庫讀取
        - 跟蹤上次更新的時間，在更新後一定時間內從主庫讀取
        - 監控從庫複製延遲，防止向滯後主庫超過一定時間的從庫發出查詢
        - 客戶端記住最近一次寫入的時間戳，確保從庫在處理該使用者的讀取請求時已經更新
        - 如果副本分佈在多個數據中心，將主庫提供服務的請求路由到包含該主庫的資料中心
    - 跨裝置寫後讀一致性
        - 需要提供跨裝置的寫後讀一致性
        - 考慮問題：
            - 記住使用者上次更新時間戳的方法變得困難，需對元資料進行中心化儲存
            - 難以保證來自不同裝置的連線會路由到同一資料中心，可能需要把來自該使用者所有裝置的請求都路由到同一個資料中心
- 單調讀
    - 非同步從庫讀取異常
        - 時光倒流
            - 發生原因：使用者從不同從庫進行多次讀取
            - 解決方法：單調讀（monotonic reads）
        - 因果律違反
            - 發生原因：分割槽（partitioned）或分片（sharded）資料庫中複製速度不一致
            - 解決方法：一致字首讀（consistent prefix reads）

<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-4.png" />
</div>

- 圖 5-4 使用者首先從新副本讀取，然後從舊副本讀取。時間看上去回退了。為了防止這種異常，我們需要單調的讀取。


- 解決複製延遲的方法
    - 設計系統來提供更強的保證（例如 寫後讀）
    - 透過主庫進行某種讀取
    - 使用事務（transaction）來簡化應用程式開發

    - 單節點事務
    - 分散式（複製和分割槽）資料庫事務（將在 第七章 和 第九章 探討）
    - 替代機制（將在 第三部分 探討）

<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-5.png" />
</div>

- 圖 5-5 如果某些分割槽的複製速度慢於其他分割槽，那麼觀察者可能會在看到問題之前先看到答案。


## 多主複製
- 基於領導者的複製模型
    - 單個主庫
    - 缺點：所有寫入必須透過主庫

- 多領導者配置（multi-leader configuration）
    - 允許多個節點接受寫入
    - 適用場景：
        - 運維多個數據中心
<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-6.png" />
</div>

- 圖 5-6 跨多個數據中心的多主複製

    - 效能
    - 容忍資料中心停機
    - 容忍網路問題
        - 需要離線操作的客戶端
    - 手機、膝上型電腦和其他裝置上的日曆應用
    - 非同步的多主複製過程
        - 協同編輯
    - 實時協作編輯應用程式
<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-7.png" />
</div>

- 圖 5-7 兩個主庫同時更新同一記錄引起的寫入衝突
    - 與離線編輯用例相似
    - 缺點：寫衝突需解決
        - 多主複製的挑戰：配置缺陷、意外反應、麻煩功能
        
<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-8.png" />
</div>

- 圖 5-8 三種可以在多主複製中使用的拓撲示例。

<div class="flex justify-between">
  <img src="images/ddia/chapter5/fig5-9.png" />
</div>

- 圖 5-9 使用多主複製時，寫入可能會以錯誤的順序到達某些副本。